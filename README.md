CTG Whitepaper V1.0
===================

Abstract
--------
The appearance of blockchain technology is an outstanding innovation, which can bring
great convenience to the cross-border currency exchange in particular. However, based
on the first generation of blockchain technology, the transaction confirmation speed of
Bitcoin (BTC) usually requires more than 10 minutes, and even dozens of minutes, which
is indeed too slow. Ethereum (ETH) is called the second generation of blockchain
technology and its added smart contract can make all kinds of applications expanded
freely in the network of blockchain. Nevertheless, the consensus algorithm of ETH
applies the POW mechanism of BTC which can optimize the transaction confirmation
speed. But it is still difficult to be put into practice.

As the renovation of the third generation of blockchain technology, EOS can shorten the
transaction confirmation speed to a second level, and even a millisecond level, which
makes cross-border payment and daily transaction easily come true. The new mechanism
of smart contract has solved the problem of network congestion of applications in ETH.
CTG’s first global ecological application platform with public chains in tourism based on
the latest blockchain technology applies the renovation of the third generation of
blockchain technology as the basic structure. Our platform can be practically applied in
multiple currencies exchange of cross-border tourism industries and relevant daily
payment. The issue of multiple currencies exchange will be first settled. Then the
corresponding modifications will be done aimed at upstream and downstream industries
of tourism. For example, expansion of super nodes together with concurrency of
distributed nodes, increase of the application bandwidth based on tokens, introduction
of the authentication system for multiple identities, etc. We will also make various DAPP
application templates for upstream and downstream industries of tourism so as to
provide convenience to the quick application of any third-party merchant so that the
secondary development is not needed. Our system will become the platform of tourism
industry chain in a specific field, which can make all kinds of applications of third-party
merchants rapidly entered as well as introduce room booking, flight reservation,
transportation, travel agency and tourist guide locking, operation of scenic spots,
management of restaurant chains, food, groceries, television, transmission of media, and
other tourism-related industries.

1.Background
---------------
Decentralization of blockchain technology was once a hot topic in the world. As a result, all kinds of applications in various industries are full of limitless imagination and inexplicable longing. However, it is difficult for current BTC network and ETH network to support so many applications. That nearly 30,000 ETH transactions are caused by CryptoKitties can lead to a huge congestion in ETH network and a SNT crowd-funding may directly paralyze ETH network. The issues of ETH criticized by people also include: social inequality aggravated by POS consensus mechanism; slow transfer speed; high service fee. All of these can show that ETH’s scalability and efficiency are still far away from the large-scale commercial application of blockchain. The bottleneck encountered in the development of blockchain requires a more stable and powerful system.

From January to April, 2017, the amount of overseas shopping consumption of Chinese tourists was RMB 27.79 billion and China has become the world’s largest country of outbound travel consumption in the last five consecutive years. The market share of outbound travel consumption of Chinese citizens is quite large and the global tourism economy will grow rapidly. After Chinese tourists enjoy a shopping spree in foreign countries, they will find their credit card bills are beyond their common sense. A bill of USD 570 will charge the service fee of USD 50. The source of the increased cost is truly an unclear accounting for most consumers. Reporters find that the accounting includes not only the two-time currency exchange fee that most consumers have no idea and the international transaction fee which is 1%~1.5% of the total amount that the issuing bank shall pay to VISA, Mastercard or other international card organizations, but also the service fee charged by some banks without any notice.

Our priority is to use the latest blockchain technology to solve the problem of multiple currencies exchange in tourism payment. Then we will make a DAPP that can be applied by any third-party merchant based on the upstream and downstream industry chain of tourism. We wish to combine technology with application to promote the development of tourism.


2.Basic Requirements for Technology of Tourism Industry Chain
-----------------------------------------------------------------
Blockchain of BTC is the data block produced according to the order and its scale is growing exponentially. However, the surge of everyday transactions, the increase of transaction confirmation time, the resource consumption of the consensus mechanism based on Proof of Work (PoW) as well as the stronger control of the whole BTC network by mining rigs and mining pools have caused unsteadiness and doubt of the application scalability in decentralized BTC.

The smart contract of ETH network has brought a glimmer of hope to applications. However, due to its own storage ability and operation mechanism, it is hard to run the large DAPP.

In order to acquire wide recognition and application, an innovative system based on the brand-new conceptive architecture must be developed and we think some basic requirements shall be met.

### 2.1 Support Millions of Users
In 2017, the network transaction amount of China UnionPay was RMB 93,900 billion and the daily number of network transaction of China UnionPay was over 10 million. If a blockchain application is expected to support millions of users just as the business of eBay, Uber, AirBnB, and Facebook, its blockchain technology applied shall be capable of handling tens of millions of active daily users. In certain case, an application may not work unless a critical mass of users is reached and therefore a platform that can handle large numbers of users is paramount.

### 2.2 Transaction Confirmation Speed
A good user experience demands a reliable feedback which costs no more than a few seconds. Currently, the transaction confirmation speed in BTC network costs over 10 minutes and even more time, which cannot meet the payment requirements of application level at all. Such long delay and wait seriously affect the user experience as well as make the application constructed on the blockchain unmatched with current products without blockchain technology. Therefore, the platform shall be able to support the second level and even the millisecond level transaction confirmation speed, which is the basic and key technique requirement of application payment.

### 2.3 Performance
Performance is the core element supporting the two vital issues above (millions of users and fast transaction confirmation speed).
The more the users make transactions in BTC or ETH, the more crowded the network will be. The slow speed is determined by the algorithm mechanism. The PoW applied by BTC stands for Proof of Work. Each transaction requires everybody to participate in the calculation and then the node that calculates fastest will keep accounts, which may greatly increase the workload but sacrifice the efficiency. The number of transfer of BTC is around 7 per second while the number of transfer of ETH is advanced to 15 per second. Compared to the traditional transaction mode, the number of transfer of Visa is 1,667 per second while the number of transfer of Paypal is 193 per second. We can see that the gap among them is still rather big.
What EOS applies is the DPOS Consensus Algorithm which can reach 10,000~100,000 per second in the harsh testing condition. In addition, EOS will apply the parallel processing technology which can make the transaction scale reached up to millions per second. If this standard is achieved, EOS may simultaneously support thousands of DAPPs on its platform.
There are different kinds of consensus algorithms at present and the DPOS that EOS applies will be our priority.

### 2.4 Security
In aspects of finance and payment, security always comes first.
The traditional payment system takes bank as media and national credit as guarantee, which is safe under certain conditions. However, business factors and human factors are inevitable. Human factors may cause a possibility of making mistakes and the wrong decision may affect the safety of the currency financial system.
BTC is forking again and again while ETH is divided into ETH and ETC, which are caused by the design of architecture so that the consensus cannot be reached. The forking of BTC is due to expansion and network congestion while the division of ETH is due to DAO. However, these factors are just the superficial fuse. In essence, it is because the design of underlying architecture has its own defects and the consensus mechanism fails to reach a consistent and effective solution. The third-party proposal was once attempted to make up the defects of the ETH architecture but the operating system was set. The only way of mending was to put a patch, which could not change from the underlying architecture. 
The solution of EOS comes from two aspects: one is the consensus and the other is the design of underlying architecture.
The delegation authorization mechanism of DPOS can be understood by the parliamentary system. The representatives can be assigned to exercise voting rights, which is the source for the competition of 21 super nodes. Among over 100 backup nodes of EOS, only 21 super nodes can be selected to exercise voting rights. When it comes to differences and problems, voting is the most effective way of treatment so as to avoid the appearance of hard-fork. Even if hard-fork appears in the design of underlying architecture, it can be treated by freezing.
In terms of underlying architecture, the problems arising from the application of public chains for all the developers of EOS blockchain can be solved by means of offering feedback to the community for remediation as well as modifying the underlying architecture according to its own demands. With this set of mechanism, it will be easy to add the effective new technology into EOS, which can accelerate the speed of modification and iteration of underlying architecture. Therefore, from this respect, EOS is relatively stable and secure. EOS also has the advantage of iteration and its scalability has been greatly improved.

### 2.5 Application Presetting
We know that the design of BTC limits its own development of new functions and applications. The network congestion of ETH can only be mended and improved by means of putting a third-party patch due to the defects of underlying architecture, however, the expansion and revolution cannot be performed in the underlying architecture.
Based on the solution of ETH, we have designed the cross-chain interaction and the independent architecture mechanism on the virtual machine, which can offer a more flexible proposal to the development of DAPP. With minor modifications, the contract of ETH is able to run on the platform.
Nevertheless, most merchants have no idea about the relevant technique concept so they don’t know how to start. That’s why we select the best platform for application presetting. We will focus on upstream and downstream industries in tourism, therefore, we need to develop the DAPP required by the merchants in advance and provide choice for them in the form of a template so as to truly achieve one-button deployment as well as quick application.

### 2.6 Password Recovery
We often hear that many people forget their own account name or password, which may cause them to fail to find the assets in the account. Such case often occurs to ordinary investors. For traditional banks, we can solve the issue by means of legal identification. However, there’s nothing that we can do in the blockchain world, which is obviously detrimental for ordinary investors to participate in.
Therefore, we consider using the relationship proof and assistance of our relatives or friends to retrieve the account or password (private key).
If the account or password is lost, the recovery procedure can be accessed when there is no activity within 30 days. A new public key shall be replaced by initiating Active Authority Modification of more than 3 people among relatives and friends in your Recovery Authority List, which will be executed after 7 days. Owner Authority Modification can be initiated after acquiring the Active Authority and the account can be retrieved after another 30 days.

### 2.7 Account Security
In the network of digital currency, it is very common for accounts to be stolen. The news about burglary of electronic wallets and exchanges always can be heard by people, which may restrict the enthusiasm of ordinary investors.
We will try to solve the issue of account security by means of multi-signature and relationship proof and more attention will be paid. 
We will force the Owner Authority of all the accounts to use multi-signature, which means there shall be at least 2 private keys or other accounts in the Owner Authority List. As a result, the danger caused by the reveal of single private key can be reduced. Cooperating with the delay of transfer, we can offer the possibility of time to help users retrieve their stolen accounts.
The Owner Authority is the highest authority of the account, which can directly change other authorities. We recommend users adding their relatives and friends to the Owner Authority List and adjusting the threshold to enable any activity of exercising the Owner Authority to require the Active Authority signatures by their relatives or friends (e.g. If the threshold value is 10, the weight value of the private key of the user is 8, and the weight value of five of relatives and friends of the users is 1 respectively, the user or his/her relatives and friends cannot take a unilateral action.). In this case, hackers have to steal the accounts of relatives and friends of the user. Even if the corresponding Active Authority is stolen, relatives and friends of the user can still use their own Owner Authority to modify the Active Authority.
The Owner Authority List can be modified by the Active Authority of the user but it requires the publicity of 30 days for execution, which can not only guarantee the account security but also delete the relatives and friends who are against the user or out of contact from the Owner Authority List.
In summary, the key of solving the issue of account security is to add the accounts of reliable relatives and friends to the Owner Authority List as well as grant suitable threshold and weight to them. The only situation that cannot be settled is that the hacker has stolen the private key of the Owner Authority and you have forgotten the private key of the Active Authority as well. Though the hacker is not able to steal anything, you cannot delete the stolen private key from the Owner Authority List and you can only transfer all of your assets to guarantee their security.

### 2.8 Minimize Resource Consumption
Current transaction confirmation of BTC and creation of new BTC for circulation require a great amount of computing power for constant operation. Such computing power is operated by miners through so-called mining rigs. BTC miners compete with each other to increase the next new transaction block for the whole BTC blockchain, which is completed by Hash Function. As a result, the miners launch a fierce arms race and a huge amount of power resources are wasted. 
The underlying architecture of CTG system applies the latest consensus algorithm of DPOS which is totally different from the mechanism of POW. There are many benefits, including no need of mining, no need of arms race, green environmental protection and energy efficiency.

### 2.9 Low Service Fee
The huge waste of computing power of BTC leads to low efficiency and the increase of the transaction cost. In the network of ETH, transaction, transfer, storage, operation, as well as development and deployment of smart contract require the consumption of gas cost. With the heat of crowd-funding of the ICO project, the increase of demands of ETH and the frequency of token transfer, the transaction cost will be added. The amount of transaction cost can be set manually and the merchant paying more money can be handled in priority, which will cause the transaction cost to be higher and higher as well as bring the injustice.
EOS is the mechanism based on rights and interests of owners. The amount of EOS tokens determines the corresponding proportion of network resources (such as transfer line, bandwidth, computing power, etc.) that can be enjoyed for free. Therefore, ETH can rent its network resources to the holders of ETH tokens while EOS can directly transfer the ownership of its network resources to the holder of EOS tokens.
In other words, if you own EOS tokens, you will acquire corresponding resources for free.
From the design and architecture of EOS, it is aimed at building a free, secure, easy-to-use, high-performance and well-compatible underlying system with public chains, which can meet the demands of commercial application. If these concepts are realized, a flood of projects and application development will be attracted and a new round of climax may be brought to the investment of blockchain. EOS is the most suitable choice of architecture for CTG so far.


3.Development Plan
------------------------

### 3.1 ICO Plan
#### 3.1.1 Issuing Amount of CTG Coin
* The issuing amount of CTG Coin is 10 billion.
* 10.5% of CTG Coin is for the global public issue.
* 11% of CTG Coin is for node reward
* 15.5% of CTG Coin is for our partners with conditional possession and the term is 3 years.
* 25% of CTG Coin is for the security fund of CTG eco-system with independent management.
* 10% of CTG Coin is for the fund of community construction, which is used to reward the team that has an outstanding contribution.
* 28% of CTG Coin is possessed by CTG management team, which is released at the ratio of no more than 5% every year to increase the market liquidity. The released funds are used for node maintenance, community promotion and sustainable construction of system. The precondition of the release is the growth of effective users of the year is over 30% of that of the previous year.

#### 3.1.2 Use of Global Public Funds of CTG Project
* 10% is for promotion and propaganda of CTG Coin and CTG system.
* 30% is for management and maintenance after CTG Coin is listed and circulated.
* 25% is for the construction of CTG eco-platform.
* 20% is for the construction of CTG’s public blockchain nodes.
* 10% is for establishment and maintenance of communities.
* 5% is for international communication.

### 3.2 Community Construction
Under the leadership of CTG team, most of tokens will be used for community construction. We will pay attention to communities at home and abroad as well as better embrace them. Good community cultures can not only help CTG but also prevent and solve more potential risks in advance.

### 3.3 Application and Innovation of Payment
As the most promising ecological system based on blockchain technology, CTG has perfectly combined the advantages of BTC and ETH as well as solved the inherent defects of the blockchain system. By means of constant construction of the basic platform, development of products, and development and iteration of commercial landing projects, CTG will gradually form the blockchain economy, improve the industry efficiency and promote the efficient and effective development of society.
As the payment token of the center, CTG will take advantage of its own features as well as make further development of applications in the following various scenarios and play a positive role.

#### 3.3.1 Travel Payment
The biggest problem of transnational travel is currency exchange. At present, BTC, ETH and other virtual currencies of blockchain are not suitable for real-time payment with small amount due to their long-time confirmation and complicated procedure.
Because of the latest consensus algorithm as well as the brand-new blockchain architecture, the theoretical value of payment confirmation time of CTG is within 1 second, which can completely be applied in all kind of landing payment scenarios.
In addition, thanks to the inherent features of virtual currencies of blockchain, CTG can exempt the troubles of currency exchange and exchange rate fluctuation.
Another highlight of CTG is the tailor-made development for mobile and wearable devices, which will make it more convenient for users and merchants to proceed business of receipt and payment as well as enjoy the benefits from CTG.

#### 3.3.2 Payment Security
Payment security is the top priority for the system development of CTG. Based on the encryption algorithm and the decentralized deployment mechanism applied by CTG, various security issues will be taken into consideration.

#### 3.3.3 Support of Mobile and Wearable Devices
In order to facilitate individual users and adapt to the requirement of scientific development, CTG will support all kinds of mobile and wearable devices. The user experience of this part is the key point of CTG.
Compared with various domestic mobile payment applications, such as Alipay, WeChat and UnionPay, CTG will make more investment on convenience, security and user experience.
With the support of this aspect, we believe the prospect of CTG will be more promising.

4.Consensus Algorithm (BFT-DPOS)
------------------------------
CTG utilizes the only known decentralized consensus algorithm proven capable of meeting the performance requirements of applications on the blockchain, which is Delegated Proof of Stake (DPOS). Under this algorithm, those who hold tokens on the blockchain of CTG may select block producers through a continuous approval voting system. Anyone may choose to participate in block production and will be given an opportunity to produce blocks, provided they can persuade token holders to vote for them.
CTG enables blocks to be produced exactly every 0.5 second and exactly one producer is authorized to produce a block at any given point in time. If the block is not produced at the scheduled time, the block for that time slot is skipped. When one or more blocks are skipped, there is a gap which is no less than 0.5 second in the blockchain.
Using CTG system, blocks are produced in rounds of 126 (6 blocks each, times 21 producers). At the start of each round, 21 unique block producers are chosen by preference of votes cast by token holders. The selected producers are scheduled in an order agreed upon by 15 or more producers. 

If a producer misses a block and has not produced any block within the last 24 hours, they will be removed from consideration until they notify the blockchain of their intention to start producing blocks again. This ensures the network operates smoothly by minimizing the number of blocks missed by excluding unreliable producers.

In theory, a DPOS blockchain does not experience any forks because, rather than compete, the block producers cooperate to produce blocks. In the event there is a fork, consensus will automatically switch to the longest chain. This method works because the rate at which blocks are added to a blockchain fork is directly correlated to the percentage of block producers that share the same consensus. In other words, a blockchain fork with more producers on it will grow in length faster than one with fewer producers, because the fork with more producers will experience fewer missed blocks.

Furthermore, no block producer should be producing blocks on two forks at the same time. A block producer caught doing this will likely be voted out. Cryptographic evidence of such double-production may also be used to automatically remove abusers.
Byzantine Fault Tolerance is added to traditional DPOS by allowing all producers to sign all blocks so long as no producer signs two blocks with the same timestamp or the same block height. Once 15 producers have signed a block, the block is deemed irreversible. Any Byzantine producer would have to generate cryptographic evidence of their treason by signing two blocks with the same timestamp or block height. Under this model, an irreversible consensus should be reachable within 1 second.

### 4.1 Transaction Confirmation
The standard DPOS blockchain has 100% block producer participation. A transaction can be considered confirmed with 99.9% certainty after an average of 0.25 seconds from time of broadcast.
In addition to DPOS, CTG system adds asynchronous Byzantine Fault Tolerance (aBFT) for faster achievement of irreversibility. The aBFT algorithm provides 100% confirmation of irreversibility within 1 second.

### 4.2Transaction as Proof of Stake (TaPoS)
CTG system requires every transaction to include part of the hash of a recent block header. This hash serves two purposes:
1.	Prevent a replay of a transaction on forks; 
2.	Signal the system that a particular user is on a specific fork.
As time goes by, all users end up directly confirming the blockchain, which makes it difficult to forge counterfeit chains. As a result, the counterfeit would not be able to transfer transactions from the legitimate chain.

5.Encryption Algorithm of CTG
-------------------------------
The major transactions of CTG are based on Elliptic Curve Digital Signature Algorithm (ECDSA) which utilizes the fast, high-efficient and secure Elliptic Curve Secret Key Algorithm to generate the sharing secret key.
ECDSA is one of the variations of Digital Signature Algorithm (DSA) and its basis is Elliptic-curve Cryptography (ECC). The theory of ECC is based on Elliptic curve point multiplication.

### 5.1 Elliptic Curve Point Multiplication
Elliptic curve point multiplication is the operation of successively adding a point along an elliptic curve to itself repeatedly and finally falling on the other point of the curve. Dotproduct is the product of a scalar and a point, which belongs to a kind of scalar multiplication.
Assuming that the starting point is the elliptic curve point P and the end point is point R on the curve, we will get the following point multiplication formula. 
R = nP
In theory, the geometric equation here that the elliptic curve selects shall be fixed, which can be represented as:
y^2 = x^3 + ax + b
In this equation, a and b are ordinary scalar parameters. The geometric curves drawn according to the equation above are shown in the following figure. The red curve stands for the elliptic curve when (a, b) = (-7, 6) and the blue curve stands for the elliptic curve when (a, b) = (-6, 6). Obviously, the values of a and b may influence the shapes of curves.
 
With the specific shape and the equation of the elliptic curve, if there is a point P on the curve, we can calculate its multiplication nP.
A concept requires to be introduced here: elliptic curve point addition. If we take the figure above as an example, we can see that point P and point Q are on the red elliptic curve. These two points are set to be added to obtain point R on the same curve. Point R comes from the conjugate point of the intersection (Point T) of the two straight lines extended from point P and point R with the elliptic curve, which is also the symmetry point of point T along the X axis. Since the above-mentioned elliptic curve itself is symmetrical along the X axis, point R must be on the curve.
Let’s review this question from the angle of algebra:
 
Point P, point Q and point R are represented in XY coordinates. Combined with the set elliptic curve formula y^2 = x^3 + ax + b, we can get the following answer:
 
By introducing a parameter which is lambda, we can add point P and point Q to obtain the coordinates of point R.
If point P coincides with point Q, the situation is called elliptic curve point double. According to the formula above, once the relative coordinates of point R is unchanged, we just need to use the special lambda:
 
For R = nP, no matter what value n takes, we can apply the methods of elliptic curve point addition and elliptic curve point double to calculate the coordinates of point R.

### 5.2 Calculation Method
The curve point Q can be calculated by the elliptic curve point P and the scalar d.
Before writing codes, the scalar d shall be represented in binary so as to utilize the methods of elliptic curve point addition and elliptic curve point double.
 
The formula above is the binary representation of d. The codes make each coefficient represented as an array d[] with the length of (m+1). The value that d[i] corresponds to the ith bit plane is 0 or 1.
Iteration is the most straightforward type, such as the bottom-up iteration:
 
The top-down iteration is as follow:
 
As you can see, compared to the bottom-up iteration, the computation load of the top-down iteration is exactly the same, however, a local variable N can be reduced.
Except the iteration type, there is the recursion type.
 
In addition, the window width can also be optimized. d is previously represented in binary and its window width can be represented as 1 which means the power of 2 adds 1 per time. If we select the window width w which is more suitable, d can be represented as:
 
Thus, m and the length of the coefficient array d[] will be smaller, which means less times of iteration (recursion) are required.

### 5.3 Elliptic Curve Cryptography
As same as the other kinds of current popular cryptography types, Elliptic Curve Cryptography (ECC) also utilizes a pair of keys consisted of a public key and a private key for encryption operation. ECC is operated based on the specific elliptic curve in a finite field. The most important operation is elliptic curve point multiplication which is the footstone of ECC.
For the formula of point multiplication which is Q = nP, if we have the starting point P and the end point Q, it’s nearly impossible to figure out n in current calculation condition. The mathematical proof process is very complicated and we will set an extreme example here. Looking back to the picture in last chapter, if the red elliptic curve is utilized for point multiplication and its left part is a closed irregular arc, the parameter n cannot be figured out as long as the multiplication of the end point Q is just located on the arc. If n is enlarged, Q will still remain in its original position after circulating some circles on the arc.

### 5.4 Parameter Group of Elliptic Curves for Encryption
The usage scenarios of ECC include digital signature, secure generation of pseudo-random number, etc. In the application, the utilized elliptic curve must be defined by a set of complete parameters which are called domain parameters. Generally, this set of parameters defined by ECC can be represented as:
(p, a, b, G, n, h)
p is a big prime number to represent the domain of all the points on the curve. a and b are respectively the coefficients of the elliptic curve equation which is y^2 = x^3 + ax + b. G is the basis point of the point multiplication on the elliptic curve. For all the sets of points on the curve obtained by point multiplication, G is their generator. n is the multiplicative order of G, which is defined as the smallest integral number that can make nG inexistent. h is an integer constant and it relates to the sets of points as well as n obtained by the elliptic curve operation. The value of h is usually 1. 

We can see the application of these elliptic curve parameters in the elliptic curve digital signature as below.

### 5.5 Theory of Elliptic Curve Digital Signature Algorithm
Elliptic Curve Digital Signature Algorithm (ECDSA) is one of the variations of Digital Signature Algorithm (DSA) and its basis is Elliptic-curve Cryptography (ECC). Compared to DSA which is based on RSA Cryptography, the length of the public key required by the operation of ECDSA can be greatly shortened. For the digital signature with a security level of 80 bits, the length of the public key required by ECDSA is just twice of that of the security level which is 160 bits. However, with the same security level, the length of the public key required by RSA is at least 1024 bits. Meanwhile, either ECDSA or RSA, the length of the signature generated by algorithm is around 320 bits. Thus, compared to RSA, the advantage of ECDSA in application is quite obvious.
Note: The concept of security level is that the security level of N bits means an attack can acquire the private key for encryption only by means of the operation of 2^N. The longer the bits are represented by the security level, the better the security performance is and the harder it is broken. Meanwhile, the cost for encryption includes the length of the public key and the length of the generated signature so it will be increased correspondingly.
ECDSA is based on DSA. DSA defines the basic steps of generation and verification process of digital signature. By comparison, we can see that ECDSA follows these definitions of DSA and then applies relevant operations of elliptic curve in some specified steps.

### 5.6 Generation of Digital Signature
Now let’s take a look at the generation process of the signature of ECDSA.
Suppose Alice wants to send Bob a message with digital signature, they first need to define a set of elliptic curve parameters for encryption which are mutually acceptable. The set of parameters can be simply represented as:
(CURVE, G, n)
CURVE stands for the elliptic curve point domain and the geometric equation. G is the basis point of all the operations of point multiplication. n is the multiplicative order of the elliptic curve. As a big prime number, the geometric meaning of n is that nG = 0, which means the result of nG is inexistent. For any positive integer smaller than n, which is m = [1，n-1], the point multiplication which is mG can obtain a reasonable point located on the elliptic curve.
Secondly, Alice requires to create a pair of keys: a private key and a public key. The private key comes from a random number within [1, n-1]:
 
The public key comes from the elliptic curve point multiplication of the private key and the basis point:
 
If Alice wants to operate the digital signature to the message m, the steps are as below:
1.	Calculate e = HASH(m). HASH is a hash encryption function, such as SHA-2 or SHA-3.
2.	Calculate z which comes from Ln of bits at the far left (top digit) of the binary form of e. Ln is the binary length of the multiplicative order n in the above-mentioned elliptic curve parameters. Please notice that z may be bigger than n but its length is absolutely no more than that of n.
3.	Randomly select an integer k which conforms to the random security of cryptography within [1, n-1].
4.	Calculate a point on the elliptic curve:
 
5.	Use the equation below to calculate r. If r == 0, go back to Step 3 to recalculate.
 
6.	Use the equation below to calculate s. If r == 0, go back to Step 3 to recalculate.
 
7.	(r, s) is the generated digital signature.
Please note that the selection of k in Step 3 shall meet the requirement of the random security of cryptography and it shall be protected as the way of the private key. What is more important, every time a new digital signature is generated, k must be updated. Otherwise, it is very easy to decipher the private key by means of the above-mentioned equations in the generation process of digital signature.
4.7 Digital Signature Verification
For Bob who is the receiver of the message, except the digital signature document, he will also receive a public key. Bob’s verification includes two parts: public key verification and signature document (r, s) verification. 

### 5.7 Public Key Verification
1.	The coordinates of the public key   shall be effective, which are not equal to an extreme empty point  . 
2.	The coordinates of the public key  shall be verified that the point must be located on the elliptic curve.
3.	The equation below shall be workable, which means the multiplicative order n of the elliptic curve and the point multiplication of the public key do not exist.
 
Signature Document Verification
1.	r and s shall be verified that both of them are integers within [1, n-1]. Otherwise, the verification fails.
2.	Calculate e= HASH(n). HAHS() is a hash function used in Step 1 of the generation process of signature.
3.	Calculate z which comes from Ln of bits at the far left of e.
4.	Calculate the parameter w:
 
5.	Calculate the two parameters u1 and u2:
 
6.	Calculate (x1, y1). If (x1, y1) is not the point on the elliptic curve, the verification fails:
 
7.	If the equation below is not workable, the verification fails.
 
The content above is the complete process of generation and verification of ECDSA. No matter what kind of programing language is utilized, generation and verification of digital signature must conform to the relevant theories and steps.

### 5.8 Elliptic Curve Digital Signature Algorithm
CTG includes the structures declaration and operation functions of the elliptic curve as well as the signature generation of ECDSA and the verified implementation of complete codes. 

### 5.9 Code Package of ECDSA
The related structures of ECDSA are shown as below:
 
Contrast to the theory of ECDSA, it is easy to understand the declaration of structures and interfaces above.
•	The structure of ecdsa.PublicKey can provide all the attributes and relevant operations of the elliptic curve by means of holding a implementation body of the interface of elliptic.Curve. Members （X，Y） of PublicKey shall correspond to the coordinates of the public key   in the algorithm theory.
•	The interface of elliptic.Curve declares the relevant operation method of the elliptic curve. Add() is the “Point Addition” operation and Double() is the “Point Doubling” operation in the point multiplication of the elliptic curve. ScalarMult() is essentially a point multiplication operation (the parameter “k” is a scalar). IsOnCurve() can inspect if the point represented by the parameter is on the elliptic curve.
•	The structure of elliptic.CurveParams implements all the methods of the interface of <Curve>. In addition, the member attribute is defined as a concrete elliptic curve. For example, (Gx, Gy) represents the basis point of the elliptic curve which is point G in the algorithm theory. N is the multiplicative order n which corresponds to the basis point. B is the parameter b in the geometric equation of the elliptic curve. Please note that the equation of the elliptic curve hidden in the code package of ECDSA is y^2 = x^3 - 3x + b. Therefore, a parameter b is enough.
•	ecdsa.PrivateKey is the major structure type which is exposed for external use and it is actually the combination of private key and public key in the algorithm theory. The member of ecdsa.PrivateKey, D, truly corresponds to the private key   in the algorithm theory.
•	ecdsa.ecdsaSignature corresponds to the generated digital signature (r,s).
Thus, from members of the structure to the method declaration, the code package of ECDSA is trying to make its theory easily understood. For the function implementation, the two functions Sign() and Verify() in ecdsa.goare workable.
 
The implementation process of the above two functions strictly conforms to the signature generation and verification process in the algorithm theory for step-by-step execution.

### 5.10 Call of ECDSA by CTG
The function implementation of ECDSA applied by CTG comes from the third-party library libsecp256k1 which is a C++ library. The library is regarded as an optimized implementation type which is tailor-made to the elliptic curve secp256k1. secp256k1 corresponds to a set of specified digital signature parameters of the elliptic curve, including a series of parameters required by curve equation and signature operation.secp256k1 is first applied in BTC and its parameter details can be seen in secp256k1.  The specified curve equation is y^2 = x^3 + 7 and its shape is shown as follow:
 
In the source code, the code package in /crypto/ is responsible for all the operations related to encryption. The source code of thelibsecp256k1 library is stored in the sub-path of /secp256k1/ and it will be called in the form of C++ library file after being compiled.

### 5.11 Digital Signature Processing
We can set the code of the transaction object in CTG as an example. The operations relating to ECDSA signature are put in the interface Signer and its implementation body.
 
Among the methods declared by the interface <Signer>, Sender() is used to analyze the public key from the digital signature carried by the object of tx and convert into the Address type variable. SignatureValues() takes out the three parts (R, S and V) of the digital signature from the object of tx. Hash() returns to the content for digital signature required by the object of tx, which means part of member variables in the object of tx will take the hash after RLP coding. Equal() is used to compare the implementation body object of Signer. Thus, the interface <Signer> and its implementation body can mainly provide operation methods of the generated digital signature.
Among the three implementation types of Signer, HomesteadSigner can save codes by means of holding the object of FrontierSigner. For EIP155, EIP(Ethereum Improvement Proposals) is the requirements summary of Ethereum.EIP155is one of the important requirements. A simple method of resisting Replay Attack is added, which requires to select more member variables in the process of RLP coding of the Hash(*Transaction) function when writing or recovering signature for tx. Therefore, Hash() in EIP155Signer is redefined.  
Recover the public key (address) from the digital signature.
The address variable function recovered/analyzed from the digital signature is called recoverPlain():
 
In the above-mentioned function body ofrecoverPlain(), crypto.ValidateSignatureValues() will be first called to verify if the digital signature is correct and effective. The method of crypto package is implemented by means of calling API of the libsecp256k1 library and conforming to the verification part relating to digital signature in the algorithm theory of ECDSA.
Secondly, R, S and V are stitched as the required digital signature string.
Then crypto.Ecrecover() is called and the public key used by digital signature is recovered by means of the content sighash of digital signature and the signature string sig. However, the method of crypto package is still implemented by means of calling API of thelibsecp256k1 library.
At last, in the returned public key, the mark head of the first byte (the value is 4) shall be removed to generate its SHA-3 hash value (256 bits) and the later 20 bytes shall be intercepted, which can generate the final returned Address type variable.
Digital Signature Generation:
The function that generates a digital signature for the object of tx is called SignTx().
 
From the function body of SignTx(), we can see that the major work of signature generation is completed by the function crypto.Sign() after the method of Signer.Hash() provides the content which requires signature (part of members in the object of Transaction obtain the hash after RLP coding). The function body of Sign() is as follow:
 
Thus, the function crypto.Sign() can complete the digital signature generation of the elliptic curve by means of calling API of the libsecp256k1 library.

### 5.12 Public Key and Address
The Address type variables used by CTG, such as the address of each account, come from the public key for digital signature of the elliptic curve. In digital signature, the public key can be repeatedly used in multiple signatures, which means all the signatures of multiple transactions (multiple different objects of Transaction) in one CTG account utilize the same public key.
Specific to the variable type, the Addresstype is a string with the length of 20 bytes and the original meaning of the public key in the digital signature of the elliptic curve shall be the coordinates (X, Y) of a point on the curve. Therefore, the relevant mutual conversion in formatting definitely exists. In the code, it refers to three different formats (types): the Address type is a string with the length of 20 bytes; the publicKey variable is a string with the unknown length; the public key on the elliptic curve is the coordinates of one point, which is represented as X，Y in ecdsa.PublicKey{}.
The conversion from the publicKey variable to the Address type is introduced in the above-mentioned function body of core.types.recoverPlain().
The format conversion functions of the publicKey string type and the ecdsa.PublicKey{} type are defined by the code package of crypto.
 
The crypto.ToECDSAPub() function converts a string of publicKey into the form of coordinates (X, Y) of a point in the ecdsa.PublicKey{} type and the FromECDSAPub() function does the opposite operation. The logic for calling the elliptic.Unmarshall() function is quite simple: 1. remove the mark head from the []bytestring;2. divide the string into two segments; 3. assign value to X and Y; 4. convert []byte into big.Int.
S256() in the above-mentioned code is a conversion function written by local code, which can return an implementation type of the interface of elliptic.Curve. It is based on the elliptic curve parameters of secp256k1, which implements all the operation functions of the curve declared by the interface of <Curve>. Thus, the types of structures/interfaces in the go language packages will be convenient to use the elliptic curve of secp256k1.

### 5.13 Algorithm Summary
o	All the digital signatures in CTG utilize ECDSA and their theoretical basis is ECC. The theoretical basis of ECC is that the private key d in the point multiplication equation Q = dP is almost impossible to be deciphered. Contrast to RSA which is based on the decomposition of big prime numbers, ECC just requires a public key with less length in the case of providing the same security level.
o	The implementation of ECDSA called by CTG comes from the libsecp256k library which is an optimized C++ library aimed at the specified elliptic curve of secp256k1. The library has been applied by BTC system.
o	The Address type used by CTG, such as the address of each account, comes from the public key for digital signature of the elliptic curve.

6.Accounts Management
-------------------
The software optimized by CTG permits all accounts to be referenced by a unique human readable name of up to 12 characters in length. The name is chosen by the creator of the account. The account creator must reserve the RAM required to store the new account until the new account stakes tokens to reserve its own RAM.
In a decentralized context, application developers will pay the nominal cost of account creation to sign up a new user. Traditional enterprises already spend significant sums of money per customer they acquire in the form of advertising, free services, etc. The cost of funding a new blockchain account should be insignificant in comparison. Fortunately, there is no need to create accounts for users already signed up by another application.

### 6.1 Actions and Handlers
Each account can send structured actions to other accounts and may define scripts to handle Actions when they are received. CTG system gives each account its own private database which can only be accessed by its own action handlers. Action handling scripts can also send actions to other accounts. The combination of actions and automated action handlers is how CTG defines smart contracts.
To support parallel execution, each account can also define any number of scopes within their database. The block producers will schedule transaction in such a way that there is no conflict over memory access to scopes and therefore they can be executed in parallel.

### 6.2 Role Based Permission Management
Permission management involves determining whether or not an action is properly authorized. The simplest form of permission management is checking that a transaction has the required signatures, but this implies that required signatures are already known. Generally, authority is bound to individuals or groups of individuals and is often compartmentalized. CTG system provides a declarative permission management system that gives accounts fine grained and high-level control over who can do what and when.
It is critical that authentication and permission management be standardized and separated from the business logic of the application. This enables tools to be developed to manage permissions in a general-purpose manner and also provide huge space for performance optimization.
Every account may be controlled by any weighted combination of other accounts and private keys. This creates a hierarchical authority structure that reflects how permissions are organized in reality and makes multi-user control over accounts easier than ever. Multi-user control is the single biggest contributor to security.
CTG system allows accounts to define what combination of keys and/or accounts can send a particular action type to another account. 

### 6.3 Named Permission Levels
Using CTG system, accounts can define named permission levels each of which can be derived from higher level named permissions. Each named permission level defines an authority; an authority is a threshold multi-signature check consisting of keys and/or named permission levels of other accounts. For example, an account's "Friend" permission level can be set for an action on the account to be controlled equally by any of the account's friends.
Another example is the Steem blockchain which has three hard-coded named permission levels: owner, active, and posting. The posting permission can only perform social actions such as voting and posting, while the active permission can do everything except change the owner. The owner permission is meant for cold storage and is able to do everything. CTG generalizes this concept by allowing each account holder to define their own hierarchy as well as the grouping of actions.

### 6.4 Permission Mapping
CTG’s optimized software allows each account to define a mapping between a contract, action or contract of any other account and their own Named Permission Level. For example, an account holder could map the account holder's social media application to the account holder's "Friend" permission group. With this mapping, any friend could post as the account holder on the account holder's social media. Even though they would post as the account holder, they would still use their own keys to sign the action. This means it is always possible to identify the friends who used the account and in what way.

### 6.5 Evaluating Permissions
When delivering an action of type "Action" from @alice to @bob, CTG system will first check to see if @alice has defined a permission mapping for @bob.groupa.subgroup.Action. If nothing is found, a mapping for @bob.groupa.subgroup then @bob.groupa, and lastly @bob will be checked. If no further match is found, the assumed mapping will be to the named permission group @alice.active.
Once a mapping is identified, signing authority is validated using the threshold multi-signature process and the authority associated with the named permission. If that fails, then it traverses up to the parent permission and ultimately to the owner permission, @alice.owner.
 
### 6.6 Default Permission Groups
CTG also allows all accounts to have an "owner" group which can do everything, and an "active" group which can do everything except change the owner group. All other permission groups are derived from "active".

The permission evaluation process is "read-only" and changes to permissions made by transactions do not take effect until the end of a block. This means that all keys and permission evaluation for all transactions can be executed in parallel. Furthermore, this means that a rapid validation of permission is possible without starting costly application logic that would have to be rolled back. Lastly, it means that transaction permissions can be evaluated as pending transactions are received and do not need to be re-evaluated as they are applied.
All things considered, permission verification represents a significant percentage of the computation required to validate transactions. Making permission verification become a read-only and trivially parallelizable process enables a dramatic increase in performance.
When replaying the blockchain to regenerate the deterministic state from the log of actions, there is no need to evaluate the permissions again. The fact that a transaction is included in a known good block is sufficient to skip this step. This dramatically reduces the computational load associated with replaying the blockchain.

### 6.7 Actions with Mandatory Delay
Time is a critical component of security. In most cases, it is not possible to know if a private key has been stolen until it has been used. Time based security is even more critical when people have applications that require keys be kept on computers connected to the internet for daily use. CTG system enables application developers to indicate that certain actions must wait a minimum period of time after being included in a block before they can be applied. During this time, they can be cancelled.
Users can then receive notice via email or text message when one of these actions is broadcast. If they did not authorize it, they can use the account recovery process to recover their account and retract the action.
The required delay depends upon how sensitive an operation is. Paying for a coffee might have no delay and be irreversible in seconds, while buying a house may require a 72-hour clearing period. Transferring an entire account to new control may take up to 30 days. The exact delays are chosen by application developers and users.

### 6.8 Recovery from Stolen Keys
CTG system provides users a way to restore control of their account when keys are stolen. An account owner can use any owner key that was active in the last 30 days along with approval from their designated account recovery partner to reset the owner key on their account. The account recovery partner cannot reset control of the account without the cooperation of the owner.
There is nothing for the hacker to gain by attempting to go through the recovery process because they already "control" the account. Furthermore, if they did go through the process, the recovery partner would likely demand identification and multi-factor authentication (phone and email). This may compromise the hacker or make the hacker gain nothing in the process.
This process is also very different from a simple multi-signature transaction. With a multi-signature transaction, another entity is made a party to every transaction that is executed. By contrast, with the recovery process the recovery partner is only a party to the recovery process and has no power over the day-to-day transactions. This dramatically reduces costs and legal liabilities for everyone involved.

7.Deterministic Parallel Execution of Applications
--------------------------------
Blockchain consensus depends upon deterministic (reproducible) behavior. This means all parallel execution must be free from the use of mutexes or other locking primitives. Without locks there must be some way to guarantee that transactions that may be executed in parallel do not create non-deterministic results.
In the blockchain based on CTG system, once parallel operation is enabled, it will be the job of the block producer to organize action delivery into independent shards so that they can be evaluated in parallel, but the process for generating the schedule need not be deterministic. This means that block producers can utilize parallel algorithms to schedule transactions.
Part of parallel execution means that when a script generates a new action it does not get delivered immediately, instead it is scheduled to be delivered in the next cycle. The reason it cannot be delivered immediately is because the receiver may be actively modifying its own state in another shard.

### 7.1 Minimizing Communication Latency
Latency is the time it takes for one account to send an action to another account and then receive a response. The goal is to enable two accounts to exchange actions back and forth within a single block without having to wait 0.5 seconds between each action. To enable this, CTG system divides each block into cycles. Each cycle is divided into shards and each shard contains a list of transactions. Each transaction contains a set of actions to be delivered. This structure can be visualized as a tree where alternating layers are processed sequentially and in parallel.
Transactions generated in one cycle can be delivered in any subsequent cycle or block. Block producers will keep adding cycles to a block until the maximum wall clock time has passed or there are no new generated transactions to deliver.
It is possible to use static analysis of a block to verify that within a given cycle no two shards contain transactions that modify the same account. So long as that invariant is maintained a block can be processed by running all shards in parallel.

### 7.2 Read-Only Action Handlers
Some accounts may be able to process an action on a pass/fail basis without modifying their internal state. If this is the case, these handlers can be executed in parallel so long as only read-only action handlers for a particular account are included in one or more shards within a particular cycle.

### 7.3 Atomic Transactions with Multiple Accounts
Sometimes it is desirable to ensure that actions are delivered to and accepted by multiple accounts atomically. In this case, both actions are placed in one transaction and both accounts will be assigned the same shard and the actions applied sequentially.

### 7.4 Partial Evaluation of Blockchain State
Scaling blockchain technology necessitates that components are modular. Everyone should not have to run everything, especially if they only need to use a small subset of the applications.
An exchange application developer runs full nodes for the purpose of displaying the exchange state to its users. This exchange application has no need for the state associated with social media applications. CTG allows any full node to pick any subset of applications to run. Actions delivered to other applications are safely ignored if your application never depends upon the state of another contract.

### 7.5 Subjective Best Effort Scheduling
CTG system cannot obligate block producers to deliver any action to any other account. Each block producer makes their own subjective measurement of the computational complexity and time required to process a transaction. This applies whether a transaction is generated by a user or automatically by a smart contract.
On a launched blockchain adopting CTG system, at a network level all transactions are billed a computational bandwidth cost based on the number of WASM instructions executed. However, each individual block producer using the software may calculate resource usage using their own algorithm and measurements. When a block producer concludes that a transaction or account has consumed a disproportionate amount of the computational capacity they simply reject the transaction when producing their own block; however, they will still process the transaction if other block producers consider it valid.
In general, so long as even 1 block producer considers a transaction as valid and under the resource usage limits then all other block producers will also accept it, but it may take up to 1 minute for the transaction to find that producer.
In some cases, a producer may create a block that includes transactions that are an order of magnitude outside of acceptable ranges. In this case, the next block producer may opt to reject the block and the tie will be broken by the third producer. This is no different than what would happen if a large block caused network propagation delays. The community would notice a pattern of abuse and eventually remove votes from the rogue producer.
This subjective evaluation of computational cost frees the blockchain from having to precisely and deterministically measure how long something takes to run. With this design, there is no need to precisely count instructions which dramatically increases opportunities for optimization without breaking consensus.

### 7.6 Deferred Transactions
CTG system supports deferred transactions that are scheduled to execute in the future. This enables computation to move to different shards and/or the creation of long-running processes that continuously schedule a continuance transaction.

### 7.7 Context Free Actions
A context free action involves computations that depend only on transaction data, but not upon the blockchain state. Signature verification, for example, is a computation that requires only the transaction data and a signature to determine the public key that signed the transaction. This is one of the most expensive individual computations a blockchain must perform, however, because this computation is context free, it can be performed in parallel.
Context free actions are like other user actions, except they lack access to the blockchain state to perform validation. Not only does this enable CTG to process all context free actions, such as signature verification in parallel, but more importantly, this enables generalized signature verification.
With support for context free actions, scalability techniques, such as Sharding, Raiden, Plasma, StateChannels, and others, become much more parallelizable and practical. This development enables efficient inter-blockchain communication and potentially unlimited scalability.

8.Token Model and Resource Usage
-------------------
Note: Cryptographic tokens referred to in this whitepaper refer to the tokens on a launched blockchain that adopts CTG system. They do not refer to the tokens applied by ETH during the first crowd-funding.
All blockchains are resource constrained and require a system to prevent abuse. In CTG system, there are three broad classes of resources that are consumed by applications:
1.Bandwidth and Log Storage (Disk);
2.Computation and Computational Backlog (CPU); 
3.State Storage (RAM).
Both of instantaneous usage and long-term usage will consume bandwidth and computation. A blockchain maintains a log of all actions and this log is ultimately stored and downloaded by all full nodes. With the log of actions, it is possible to reconstruct the state of all applications.
The computational debt is calculations that must be performed to regenerate state from the action log. If the computational debt grows too large, it becomes necessary to take snapshots of the blockchain's state and discard the blockchain's history. If computational debt grows too quickly, it may take 6 months to replay 1-year worth of transactions. It is critical, therefore, that the computational debt be carefully managed.
Blockchain state storage is information that is accessible from application logic. It includes information such as order books and account balances. If the state is never read by the application, then it should not be stored. For example, blog post content and comments are not read by application logic, so they should not be stored in the blockchain's state. Meanwhile the existence of a post/comment, the number of votes, and other properties do get stored as part of the blockchain's state.
Block producers publish their available capacity for bandwidth, computation, and state. CTG system allows each account to consume a percentage of the available capacity proportional to the quantity of tokens held in a 3-day staking contract. For example, if a blockchain based on CTG system is launched and if an account holds 1% of the total tokens distributable pursuant to that blockchain, that account has the potential to utilize 1% of the state storage capacity.
Adopting CTG system on a launched blockchain means bandwidth and computational capacity are allocated on a fractional reserve basis because they are transient (unused capacity cannot be saved for future use). The algorithm used by CTG system is similar to the algorithm used by Steem to rate-limit bandwidth usage.

### 8.1 Objective and Subjective Measurements
As discussed earlier, instrumenting computational usage has a significant impact on performance and optimization, therefore, all resource usage constraints are ultimately subjective, and enforcement is done by block producers according to their individual algorithms and estimates. These would typically be implemented by a block producer via the writing of a custom plugin.
Nevertheless, there are certain things that are trivial to measure objectively. The number of actions delivered and the size of the data stored in the internal database are cheap to measure objectively. CTG enables block producers to apply the same algorithm over these objective measures but may choose to apply stricter subjective algorithms over subjective measurements.

### 8.2 Receiver Pays
Traditionally, it is the business that pays for office space, computational power, and other costs required to run the business. The customer buys specific products from the business and the revenue from those product sales is used to cover the business costs of operation. Similarly, no website obligates its visitors to make micropayments for visiting its website to cover hosting costs. Therefore, decentralized applications should not force its customers to pay the blockchain directly for the use of the blockchain.
A launched blockchain that uses CTG system does not require its users to pay the blockchain directly for its use.

### 8.3 Delegating Capacity
A holder of tokens on a blockchain of CTG may not have an immediate need to consume all or part of the available bandwidth. He or she can delegate or rent such unconsumed bandwidth to others. The block producers running CTG on such blockchain will recognize this delegation of capacity and allocate bandwidth accordingly.

### 8.4 Separating Transaction Costs from Token Value
One of the major benefits of CTG is that the amount of bandwidth available to an application is entirely independent of any token price. If an application owner holds a relevant number of tokens on a blockchain of CTG, the application can run indefinitely within a fixed state and bandwidth usage. In such case, developers and users are unaffected from any price volatility in the token market and therefore not reliant on a price feed. In other words, a blockchain that adopts CTG enables block producers to naturally increase bandwidth, computation, and storage available per token independent of the token's value.
A blockchain using CTG also awards tokens for block producers every time they produce a block. The value of the tokens will impact the amount of bandwidth, storage, and computation a producer can afford to purchase. This model naturally leverages rising token values to increase network performance.

### 8.5 State Storage Costs
While bandwidth and computation can be delegated, storage of application state will require an application developer to hold tokens until that state is deleted. If state is never deleted, the tokens are effectively removed from circulation.

### 8.6 Block Rewards
The number of tokens created is determined by the median of the desired pay published by all block producers. With the change of the demand of market liquidity, after the tokens are completely released, if the examination system measures that the increase of the annual demand of market liquidity exceeds 5%, CTG may be configured to enforce a cap on producer awards such that the total annual increase in token supply does not exceed 5%, which is only used for special release.

### 8.7 Worker Proposal System
In addition to electing block producers, pursuant to a blockchain based on CTG, token holders can elect a number of Worker Proposals designed to benefit the community. The winning proposals will receive tokens of up to a configured percent of the token inflation minus those tokens that have been paid to block producers. These proposals will receive tokens proportional to the votes each application has received from token holders, up to the amount they request for performing their work. The elected proposals can be replaced by newly elected proposals by token holders.

9.Governance
-----------------
Governance is the process by which people in a community:
1.	Reach consensus on subjective matters of collective action that cannot be captured entirely by software algorithms;
2.	Carry out the decisions they reach; 
3.	Alter the governance rules themselves via Constitutional amendments.
The blockchain of CTG implements a governance process that efficiently directs the existing influence of block producers. Absent a defined governance process, prior blockchains relied on special, informal and often controversial governance processes that result in unpredictable outcomes.
A blockchain based on CTG recognizes that power originates with the token holders who delegate that power to the block producers. The block producers are given limited and checked authority to freeze accounts, update defective applications, and propose hard forking changes to the underlying protocol.
Embedded into CTG is the election of block producers. Before any change can be made to the blockchain, these block producers must approve it. If the block producers refuse to make changes desired by the token holders, they can be voted out. If the block producers make changes without permission of the token holders, all other non-producing full-node validators (exchanges, etc.) will reject the change.

### 9.1 Freezing Accounts
Sometimes a smart contact behaves in an aberrant or unpredictable manner and fails to perform as intended; other times an application or account may discover an exploit that enables it to consume an unreasonable amount of resources. When such issues inevitably occur, the block producers have the power to rectify such situations.
The block producers on all blockchains have the power to select which transactions are included in blocks which gives them the ability to freeze accounts. The blockchain using CTG formalizes this authority by subjecting the process of freezing an account to a 15/21 vote of active producers. 
If the producers abuse the power, they can be voted out and an account will be unfrozen.

### 9.2 Changing Account Code
When all else fails and an "unstoppable application" acts in an unpredictable manner, the blockchain using CTG allows the block producers to replace the account's code without hard forking the entire blockchain. Similar to the process of freezing an account, this replacement of the code requires a 15/21 vote of elected block producers.

### 9.3 Constitution
CTG enables blockchain to establish a peer-to-peer terms of service agreement or a binding contract among those users who sign it, referred to as a "constitution". The content of this constitution defines obligations among the users which cannot be entirely enforced by code and facilitates dispute resolution by establishing jurisdiction and choice of law along with other mutually accepted rules. Every transaction broadcast on the network must incorporate the hash of the constitution as part of the signature and thereby explicitly binds the signer to the contract.
The constitution also defines the human-readable intent of the source code protocol. This intent is used to identify the difference between a bug and a feature when errors occur and guides the community on what fixes are proper or improper.

### 9.4 Upgrading the Protocol & Constitution
CTG defines the following process by which the protocol, as defined by the canonical source code and its constitution, can be updated:
1.Block producers propose a change to the constitution and obtains 15/21 approval.
2.Block producers maintain 15/21 approval of the new constitution for 30 consecutive days.
3.All users are required to indicate acceptance of the new constitution as a condition of future transactions being processed.
4. Block producers adopt changes to the source code to reflect the change in the constitution and propose it to the blockchain using the hash of the new constitution.
5. Block producers maintain 15/21 approval of the new code for 30 consecutive days.
6. Changes to the code take effect 7 days later, giving all non-producing full nodes 1 week to upgrade after ratification of the source code.
7. All nodes that do not upgrade to the new code shut down automatically.

By default, configuration of CTG, the process of updating the blockchain to add new features takes 2 to 3 months, while updates to fix non-critical bugs that do not require changes to the constitution can take 1 to 2 months.
The block producers may accelerate the process if a software change is required to fix a harmful bug or security exploit that is actively harming users. Generally speaking it could be against the constitution for accelerated updates to introduce new features or fix harmless bugs.


10.Scripts and Virtual Machines
---------------
CTG will be first and foremost a platform for coordinating the delivery of authenticated messages (called “actions”) to accounts. The details of scripting language and virtual machine are implementation specific details that are mostly independent from the design of CTG technology. Any language or virtual machine that is deterministic and properly sandboxed with sufficient performance can be integrated with API of CTG.

### 10.1 Clear Actions Schema
All actions sent between accounts are defined by a schema which is part of the blockchain consensus state. This schema allows seamless conversion between binary and JSON representation of the actions.

### 10.2 Defining Database of Schema
Database state is also defined by using a similar schema. This ensures that all data stored by all applications is in a format that can be interpreted as human readable JSON format but stored and manipulated with the efficiency of binary.

### 10.3 API Generic Multi Index Database API
Developing smart contracts requires a defined database schema to track, store, and find data. Developers commonly need the same data sorted or indexed by multiple fields and to maintain consistency among all the indices.

### 10.4 Separating Authentication from Application
To maximize parallelization opportunities and minimize the computational debt associated with regenerating application state from the transaction log, CTG separates validation logic into three sections:
1.Validating that an Action is internally consistent;
2.Validating that all preconditions are valid;
3.Modifying the application state.

Validating the internal consistency of an action is read-only requires no access to blockchain state. This means that it can be performed with maximum parallelism. Validating preconditions, such as required balance, is read-only and therefore can also benefit from parallelism. Only modification of application state requires write access and must be processed sequentially for each application.
Authentication is the read-only process of verifying that an action can be applied. Application is actually doing the work. In real time, both calculations are required to be performed. However, once a transaction is included in the blockchain, it is no longer necessary to perform the authentication operations.

11.Inter Blockchain Communication
----------------
CTG is designed to facilitate inter-blockchain communication. This is achieved by generating proof of action existence and proof of action sequence. These proofs combined with the application architecture designed around Action passing enables the details of inter-blockchain communication and proof validation to be hidden from application developers, enabling high level abstractions to be presented to developers.

### 11.1 Merkle Proofs for Light Client Validation (LCV)
Integrating with other blockchains is much easier if clients do not need to process all transactions. After all, an exchange only cares about transfers in and out. It would also be ideal if the exchange could utilize lightweight merkle proofs of deposit rather than having to trust its own block producers entirely. At the very least a chain's block producers would like to maintain the smallest possible overhead when synchronizing with another blockchain.
The goal of LCV is to enable the generation of relatively light-weight proof of existence that can be validated by anyone tracking a relatively light-weight data set. In this case, the objective is to prove that a particular transaction was included in a particular block and that the block is included in the verified history of a particular blockchain.
Bitcoin supports validation of transactions assuming all nodes have access to the full history of block headers which amounts to 4MB of block headers per year. At 10 transactions per second, a valid proof requires about 512 bytes. This works well for a blockchain with a 10-minute block interval, but is no longer "light" for blockchains with a 0.5 second block interval.
CTG enables lightweight proofs for anyone who has any irreversible block header after the point in which the transaction was included. Using the hash-linked structure shown, it is possible to prove the existence of any transaction with a proof less than 1024 bytes in size.
Each block has an ID in the blockchain, and the header is set as irreversible block. It is possible to prove that the block is included in the blockchain. This proof takes ceil(log2(N)) digests for its path, where N is the number of blocks in the chain. Given a digest method of SHA256, you can prove the existence of any block in a chain which contains 100 million blocks in 864 bytes.
When it comes time to validate proofs on other chains, there are a wide variety of time/ space/ bandwidth optimizations that can be made. Tracking all block headers (420 MB/year) will keep proof sizes small. Tracking only recent headers can offer a trade-off between minimal long-term storage and proof size. Alternatively, a blockchain can use a lazy evaluation approach where it remembers intermediate hashes of past proofs. New proofs only have to include links to the known sparse tree. The exact approach used will necessarily depend upon the percentage of foreign blocks that include transactions referenced by merkle proof.
After a certain density of interconnectedness, it becomes more efficient to simply have one chain contain the entire block history of another chain and eliminate the need for proofs all together. For performance reasons, it is ideal to minimize the frequency of inter-chain proofs.

### 11.2 Latency of Interchain Communication
When communicating with another outside blockchain, block producers must wait until there is 100% certainty that a transaction has been irreversibly confirmed by the other blockchain before accepting it as a valid input. Using a CTG-based blockchain and DPOS with 0.5 second blocks and the addition of Byzantine Fault Tolerant irreversibility, this takes approximately 0.5 second. If any chain's block producers do not wait for irreversibility it would be like an exchange crediting a deposit that was later reversed and could impact the validity of the blockchain's consensus. CTG uses both DPOS and aBFT to provide rapid irreversibility.

### 11.3 Proof of Completeness
When using merkle proofs from outside blockchains, there is a significant difference between knowing that all transactions processed are valid and knowing that no transactions have been skipped or omitted. While it is impossible to prove that all of the most recent transactions are known, it is possible to prove that there have been no gaps in the transaction history. CTG facilitates this by assigning a sequence number to every action delivered to every account. A user can use these sequence numbers to prove that all actions intended for a particular account have been processed and that they were processed in order.

### 11.4 Segregated Witness
The concept of Segregated Witness (SegWit) is that transaction signatures are not relevant after a transaction is immutably included in the blockchain. Once it is immutable, the signature data can be pruned and everyone else can still derive the current state. Since signatures represent a large percentage of most transactions, SegWit represents a significant savings in disk usage and syncing time.
This same concept can apply to merkle proofs used for inter-blockchain communication. Once a proof is accepted and irreversibly logged into the blockchain, the 2KB of sha256 hashes used by the proof are no longer necessary to derive the proper blockchain state. In the case of inter-blockchain communication, this savings is 32 times greater than the savings on normal signatures.
Another example of SegWit would be for Steem blog posts. Under this model a post would contain only the sha256 (blog content) and the blog content would be in the segregated witness data. The block producer would verify that the content exists and has the given hash, but the blog content would not need to be stored in order to recover the current state from the blockchain log. This enables proof that the content was once known without having to store the said content forever.

12.Conclusion
------------
In conclusion, CTG applies the most reasonable blockchain technology currently and make targeted improvement in order to highlight the practical value of business application as well as promote our project. In the coming future, we believe CTG platform will create a grand view of practical applications together with many like-minded partners.

13.References
--------------
1.	http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it
2.	https://en.bitcoin.it/wiki/Smart_Property
3.	https://en.bitcoin.it/wiki/Contracts
4.	http://www.weidai.com/bmoney.txt
5.	http://www.finney.org/~hal/rpow/
6.	http://szabo.best.vwh.net/securetitle.html
7.	http://bitcoin.org/bitcoin.pdf
8.	https://namecoin.org/
9.	http://en.wikipedia.org/wiki/Zooko's_triangle
10.	https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit
11.	https://github.com/mastercoin-MSC/spec
12.	http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/
13.	https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification
14.	http://en.wikipedia.org/wiki/Merkle_tree
15.	http://en.wikipedia.org/wiki/Patricia_tree
16.	https://eprint.iacr.org/2013/881.pdf
17.	http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html
18.	http://www.youtube.com/watch?v=Pu4PAMFPo5Y
19.	https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
20.	https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree
21.	http://sourceforge.net/p/bitcoin/mailman/message/31709140/
22.	http://www.weidai.com/bmoney.txt
23.	http://www.hashcash.org/papers/hashcash.pdf
24.	https://github.com/eosio


https://ctg-pay.oss-ap-southeast-1.aliyuncs.com/file/ctg_technical_whitepaper_cn.pdf
